#lang racket

(require "classes.rkt" "compiler_directives.rkt" "forth_bit_words.rkt"
	 "forth_control_words.rkt" "forth_io_words.rkt" "forth_read.rkt"
	 "forth_state_words.rkt" "rvector.rkt")


(provide compile compile-and-run compile-to-vector
         compile-to-string program-size compile-all-to-list)

(add-directives!)
(add-bit-words!)
(add-control-words!)
(add-io-words!)
(add-state-words!)

;; Input:  Code in the form of an input port, or a string.
;; Output:  An interpreter% object that has the program loaded into memory.
(define (compile code-port)
  (when (string? code-port)
    (set! code-port (open-input-string code-port)))

  (let [(compiler (new compiler%))
	(old (current-input-port))]
    (forth_read 'clear)
    (current-input-port code-port)
    (send compiler compile-loop)
    (current-input-port old)
    (send compiler get 'interpreter)))

;; Compiles ArrayForth and runs it using the resulting interpreter.
;; Output is typically generated by .ns and its variants in the code.
(define (compile-and-run code-port)
  (send (compile code-port) interpret))

;; Compiles ArrayForth into F18 code.
;; Outputs a vector of strings and bytes/numbers.
;; If #:use-bytes? is set to #f (the default), the output will contain numbers, otherwise, output will contain numbers.
;; If #:use-nop-and-ret? is set to #f, output will contain ";" and ".", else output will contain "nop" and "ret".
(define (compile-to-vector code-port
			   #:bytes? [use-bytes? #f]
			   #:use-nop-and-ret? [no-punct? #t])
  ;; Compilation stores everything into memory.
  (let* [(interpreter (compile code-port))
	 (result (plain-vector (send interpreter get 'memory)))]
    ;; Convert bytes to integers if necessary
    (unless use-bytes?
      (define (safe-bytes-to-int x)
        (cond [(bytes? x) (integer-bytes->integer x #t #t)]
              [(list? x) (map safe-bytes-to-int x)]
              [else x]))
      (vector-map! safe-bytes-to-int result))

    ;; Convert . and ; to nop and ret respectively, if necessary
    (let [(replace-nop (if no-punct? "nop" "."))
	  (find-nop (if no-punct? "." "nop"))
	  (replace-ret (if no-punct? "ret" ";"))
	  (find-ret (if no-punct? ";" "ret"))]
      (define (safe-punct-transform x)
	(cond [(equal? x find-nop) replace-nop]
	      [(equal? x find-ret) replace-ret]
	      [(list? x) (map safe-punct-transform x)]
	      [else x]))
      (vector-map! safe-punct-transform result))
    result))

(define (compile-all-to-list code-port
                             #:bytes? [use-bytes? #f]
                             #:use-nop-and-ret? [no-punct? #t])
  "return compiled code for all nodes in the format:
 ((node-num . code-string) ...)"

  (define (convert mem)
    (unless use-bytes?
      (define (safe-bytes-to-int x)
        (cond [(bytes? x) (integer-bytes->integer x #t #t)]
              [(list? x) (map safe-bytes-to-int x)]
              [else x]))
      (vector-map! safe-bytes-to-int mem))

    ;; Convert . and ; to nop and ret respectively, if necessary
    (let [(replace-nop (if no-punct? "nop" "."))
	  (find-nop (if no-punct? "." "nop"))
	  (replace-ret (if no-punct? "ret" ";"))
	  (find-ret (if no-punct? ";" "ret"))]
      (define (safe-punct-transform x)
	(cond [(equal? x find-nop) replace-nop]
	      [(equal? x find-ret) replace-ret]
	      [(list? x) (map safe-punct-transform x)]
	      [else x]))
      (vector-map! safe-punct-transform mem))
    mem)

  (let* [(interpreter (compile code-port))
         (result '())
         (empty (vector))
         (mem 0)]

    (for [(core (send interpreter get 'cores))]
      (set! mem (plain-vector (get-field memory core)))
      (unless (equal? mem empty)
        ;;(set! mem (code-vector-to-string (convert mem)))
        (set! mem (convert mem))
        (set! result (cons mem result))))
    (reverse result)))

(define (code-vector-to-string v)
  (define (convert s)
    (cond [(string? s) s]
	  [(number? s) (number->string s)]
	  [(list? s)
	   (foldr (lambda (x y) (string-append x " " y)) ""
		  (map convert s))]
	  [else (raise "Unknown memory element")]))
  (foldr (lambda (x y) (string-append (convert x) " " y)) ""
	 (vector->list v)))

(define (compile-to-string code-port #:use-nop-and-ret? [no-punct? #t])
  (code-vector-to-string (compile-to-vector code-port
                                            #:bytes? #f
                                            #:use-nop-and-ret? no-punct?)))



(define (program-size code-port)
  (vector-length (compile-to-vector code-port
                                    #:bytes? #f
                                    #:use-nop-and-ret? #f)))

#|
(program-size "yellow 2 node
0 org
1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ,
green
: sum 1 0 b! !b 2 1 b! !b 0 a! @+ @+ ;")

(define (f a) (display a))

(with-output-to-string (lambda () (f "hello")))|#
