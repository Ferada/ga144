#lang racket

(require (only-in racket [equal? equal-case-sensitive?]))
(require "arithmetic.rkt" "rvector.rkt" "forth_read.rkt" "forth_num_convert.rkt")
(require "forth_state.rkt" "forth_state_words.rkt" "forth_bit_words.rkt" "forth_io_words.rkt" "forth_control_words.rkt")
(require "forth_base.rkt")

(provide compile-and-run compile-to-vector compile-to-string)

; Compiles ArrayForth and runs it using this interpreter (not fully functional yet).
; Output is typically generated by .ns and .nr in the code
(define (compile-and-run code-port)
  (reset!)
  (compile code-port)
  (code-loop))

; Compiles ArrayForth into F18 code.  Outputs a vector of strings and bytes/numbers.
; If #:use-bytes? is set to #f (the default), the output will contain numbers, otherwise, output will contain numbers.
; If #:use-nop-and-ret? is set to #f, output will contain ";" and ".", else output will contain "nop" and "ret".
(define (compile-to-vector code-port #:bytes? [use-bytes? #f] #:use-nop-and-ret? [no-punct? #t])
  (reset!)

  ; Use node 0 for compilation
  (push-int! dstack 0)
  ((rvector-ref codespace (entry-code (find-entry compiler-directives "node"))) compiler)
  ((rvector-ref codespace (entry-code (find-entry compiler-directives "green"))) compiler)
  (compile code-port)

  ; Compilation stores everything into memory.
  (let ((result (plain-vector memory)))
    ; Convert bytes to integers if necessary
    (unless use-bytes?
	    (vector-map! (lambda (code)
			   (if (bytes? code)
			       (integer-bytes->integer code #t #t)
			       code))
			 result))

    ; Convert . and ; to nop and ret respectively, if necessary
    (let [(replace-nop (if no-punct? "nop" "."))
	  (find-nop (if no-punct? "." "nop"))
	  (replace-ret (if no-punct? "ret" ";"))
	  (find-ret (if no-punct? ";" "ret"))]
      (vector-map! (lambda (code)
		     (cond [(equal? code find-nop) replace-nop]
			   [(equal? code find-ret) replace-ret]
			   [else code]))
		   result))
    result))

(define (compile-to-string code-port #:use-nop-and-ret? [no-punct? #t])
  (define (convert s)
    (cond [(string? s) s]
	  [(number? s) (number->string s)]
	  [(not s) ""]
	  [else (raise "Unknown memory element")]))
  (foldr (lambda (x y) (string-append (convert x) " " y)) ""
	 (vector->list (compile-to-vector code-port #:bytes? #f #:use-nop-and-ret? no-punct?))))
