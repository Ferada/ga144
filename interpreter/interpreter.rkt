;; A bit-level arrayForth interpreter.
#lang racket

(require compatibility/defmacro
         "../compiler/assemble.rkt"
         "../compiler/disassemble.rkt"
         "../compiler/compile.rkt"
         "../compiler/util.rkt"
         "bit-functions.rkt"
         "state.rkt"
         "stack.rkt")

(define DEBUG? #f)
(define _PORT-DEBUG? #t)
(define DISPLAY_STATE? #f)
(define port-debug-list '(1 2))
(define (PORT-DEBUG? coord) (and _PORT-DEBUG? (member coord port-debug-list)))


(provide (all-defined-out))
(define &UP #x145) ;325
(define &DOWN #x115) ;277
(define &LEFT #x175) ;373
(define &RIGHT #x1d5) ;469
(define &IO #x15d)
(define LEFT 0)
(define UP 1)
(define DOWN 2)
(define RIGHT 3)

(define opcodes (vector "ret" "ex" "jump" "call" "unext" "next" "if"
                        "-if" "@p" "@+" "@b" "@" "!p" "!+" "!b" "!" "+*"
                        "2*" "2/" "-" "+" "and" "or" "drop" "dup" "pop"
                        "over" "a" "nop" "push" "b!" "a!"))

(define time 0)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 8x18 node matrix

(define nodes (make-vector 144 #f))

;;builds matrix of 144 f18 nodes
(define (build-node-matrix)
  (for ([i 144])
    (vector-set! nodes i (make-node i)))
  (vector-map node:init-ludr-port-nodes nodes))

(define (coord->node coord)
  (let ([index (coord->index coord)])
    (if (and (>= index 0)
             (< index 144))
        (vector-ref nodes index)
        #f ;;TODO: return pseudo node
        )))

(define (index->node index)
  (vector-ref nodes index))

(define (coord->row coord)
  (quotient coord 100))

(define (coord->col coord)
  (remainder coord 100))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; suspension and wakeup

;;TODO: better way to clone vector
(define active-nodes #f)
;;index of last active node in the 'active-nodes' array
(define last-active-index 143) ;;all nodes are initially active

(define current-node-index 0) ;;index into 'active-nodes' of the current node
(define current-node #f)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; program loading

;;compiles, assembles, and loads code into nodes
(define (compile-and-load in
                          [include-end-token? #f]
                          #:compiled-file [compiled-file #f]
                          #:assembled-file [assembled-file #f])
  (let* ([n 0]
         [code 0]
         [node 0]
         [compiled (compile in)])
    (when compiled-file
      (with-output-to-file compiled-file
        (lambda () (display-compiled compiled))
        #:exists 'replace))
    (assemble compiled)
    (for ([code compiled])
      (set! node (coord->node (car code)))
      (node:load-code node (TEMPORARY_CONVERT (cdr code))))
    (when assembled-file
      (with-output-to-file assembled-file
        (lambda () (display-disassemble compiled))
        #:exists 'replace))))

(define (TEMPORARY_CONVERT code)
  ;;Converts the vector generated by the compiler3/ compiler
  ;;to the list expected the loading functions here.
  (define (find-first v [i 0])
    (if (eq? (vector-ref v i) #f)
        (find-first v (add1 i))
        i))
  (define (vector-reverse v)
    (list->vector (reverse (vector->list v))))
  (let* ((ret '())
         (v (vector-reverse code))
         (first (find-first v)))
    (for ([i (range first (vector-length v))])
      (set! ret (cons (vector-ref v i) ret)))
    ret))

(define (load-file file)
  (call-with-input-file file compile-and-load))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; node object

(define (make-node index)
  (define self (make-vector N-METHODS))

  (define active-index index);;index of this node in teh 'active-nodes' vector
  (define suspended #f)
  (define coord (index->coord index))

  ;; stacks:
  (define dstack (make-stack 8))
  (define rstack (make-stack 8))

  ;; registers:
  (define A 0)
  (define B 0)
  (define P 0)
  (define I 0)
  (define R 0)
  (define S 0)
  (define T 0)
  (define IO #x15555)

  (define memory #f)

  (define blocking-read #f)
  (define blocking-write #f)
  (define blocking #f)

  (define instructions (make-vector 35))
  (define carry-bit 0)
  (define extended-arith? #f)

  (define (18bit n)
    (if (number? n);;temp fix
        (& n #x3ffff)
        n))

  ;; Pushes to the data stack.
  (define (d-push! value)
    (push-stack! dstack S)
    (set! S T)
    (set! T (18bit value)))

  ;; Pushes to the rstack stack.
  (define (r-push! value)
    (push-stack! rstack R)
    (set! R value))

  ;; Pops from the data stack.
  (define (d-pop!)
    (let ([ret-val T])
      (set! T S)
      (set! S (pop-stack! dstack))
      ret-val))

  ;; Pops from the rstack stack.
  (define (r-pop!)
    (let ([ret-val R])
      (set! R (pop-stack! rstack))
      ret-val))

  ;; Return the value of p or a incremented as appropriately. If the
  ;; register points to an IO region, does nothing. Otherwise increment
  ;; the register circularly within the current memory region (RAM or
  ;; ROM).
  (define (incr curr) ;; DB001 section 2.2
    (if (> (& curr #x100) 0)
        curr
        (let ([bit9 (& curr #x200)]
              [addr (& curr #xff)])
          (ior (cond [(< addr #x7F) (add1 addr)]
                     [(= addr #x7F) 0]
                     [(< addr #xFF) (add1 addr)]
                     [(= addr #xFF) #x80])
               bit9))))


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; suspension and wakeup
  (define (remove-from-active-list)
    (let ((last-active-node (vector-ref active-nodes last-active-index)))
      ;;swap self with current node in 'active-nodes'
      (vector-set! active-nodes current-node-index last-active-node)
      (vector-set! active-nodes last-active-index self)
      ;;save the new node indices
      (set! active-index last-active-index)
      (node:set-aindex last-active-node current-node-index)
      ;;decrement the number of active nodes
      (set! last-active-index (sub1 last-active-index))))

  (define (add-to-active-list)
    (set! last-active-index (add1 last-active-index))
    (let ((first-inactive-node (vector-ref active-nodes last-active-index)))
      ;;swap self with firt inactive node in 'active-nodes'
      (vector-set! active-nodes active-index first-inactive-node)
      (vector-set! active-nodes last-active-index self)
      ;;save the new node indices
      (node:set-aindex first-inactive-node active-index)
      (set! active-index last-active-index)))

  (define (suspend)
    (remove-from-active-list)
    (set! suspended #t))

  (define (wakeup)
    (add-to-active-list)
    (set! suspended #f))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; ludr port communication

  ;; adjacent nodes that are suspended, waiting for this node to read to a port
  (define writing-nodes (make-vector 4 #f))

  ;;values written to a ludr port by a pending write
  ;;each node in the 'writing-nodes' array has a corresponding value here
  (define port-vals (make-vector 4 #f))

  ;; adjacent nodes that are suspended, waiting for this node to write to a port
  (define reading-nodes (make-vector 4 #f))

  ;;maps ludr ports to adjacent nodes
  (define ludr-port-nodes #f)

  (define (port-read port)
    (when PORT-DEBUG? (printf "[~a](port-read ~a)\n" coord port))
    ;;read a value from a ludr port
    ;;returns #t if value is one the stack, #f if we are suspended waiting for it
    (let ((writing-node (vector-ref writing-nodes port)))
      (if writing-node
          (begin ;;value was ready
            (when PORT-DEBUG? (printf "       value was ready: ~a\n"
                                      (vector-ref port-vals port)))
            (d-push! (vector-ref port-vals port))
            ;;clear state from last reading
            (vector-set! writing-nodes port #f)
            ;;let other node know we read the value
            (node:finish-port-write writing-node)
            #t)
          (begin ;;else: suspend while we wait for other node to write
            (when PORT-DEBUG? (printf "       suspending\n"))
            (node:receive-port-read (vector-ref ludr-port-nodes port) port self)
            (suspend)
            #f))))

  (define (port-write port value)
    (when PORT-DEBUG? (printf "[~a](port-write ~a  ~a)\n" coord port value))
    ;;writes a value to a ludr port
    (let ((reading-node (vector-ref reading-nodes port)))
      (if reading-node
          (begin
            (when PORT-DEBUG? (printf "       target is ready\n"))
            (vector-set! reading-nodes port #f)
            (node:finish-port-read reading-node value)
            #t)
          (begin
            (when PORT-DEBUG? (printf "       suspending\n"))
            (node:receive-port-write
             (vector-ref ludr-port-nodes port) port value self)
            (suspend)
            #f))))

  (define (finish-port-read val)
    ;;called by adjacent node when it writes to a port we are reading from
    (when PORT-DEBUG? (printf "[~a](finish-port-read  ~a)\n" coord val))
    (d-push! val)
    (wakeup))
  (declare-public finish-port-read)

  (define (finish-port-write)
    ;;called by adjacent node when it reads from a port we are writing to
    (when PORT-DEBUG? (printf "[~a](finish-port-write)\n" coord))
    (wakeup))
  (declare-public finish-port-write)

  (define (receive-port-read port node)
    ;;called by adjacent node when it is reading from one of our ports
    (when PORT-DEBUG?
      (printf "[~a](receive-port-read ~a   ~a)\n" coord port (node:str node)))
    (vector-set! reading-nodes port node))
  (declare-public receive-port-read)

  (define (receive-port-write port value node)
    (when PORT-DEBUG?
      (printf "[~a](receive-port-write ~a  ~a  ~a)\n"
              coord port value (node:str node)))
    ;;called by adjacent noe when it is writing to one of our ports
    (vector-set! writing-nodes port node)
    (vector-set! port-vals port value))
  (declare-public receive-port-write)
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; memory accesses

  ;;Determine if we are in RAM or ROM, return the index for that memory location
  ;;DB001 section 2.2  Top half of RAM and ROM is repeated
  (define (region-index addr)
    (if (>= addr #x80);;ROM
        (if (> addr #x0BF)
            (- addr #x0BF)
            addr)
        (if (> addr #x3F)

            (- addr #x3F)
            addr)))

  (define (port-addr? addr)
    ;;True if ADDR is an IO port or register, else False
    (> (& addr #x100) 0))

  ;;Port address in the 'memory' vector (0x100 - 0x1ff) contain
  ;;vectors of functions to call when reading or writing to that port.
  ;;First element is the read function, second is the write function.
  ;;Invalid port numbers have the value #f

  (define (read-memory addr)
    ;;pushes the value at memory location ADDR onto the data stack
    (if (port-addr? addr)
        (let ((x (vector-ref memory addr)))
          (if (vector? x)
              ((vector-ref x 0))
              (printf "ERROR: read-memory(~a) - invalid port\n" addr)))
        (d-push! (vector-ref memory (region-index addr)))))

  (define (set-memory! addr value)
    (if (port-addr? addr)
        (let ((x (vector-ref memory addr)))
          (if x
              ((vector-ref x 1) value)
              (printf "ERROR: set-memory!(~a, ~a) - invalid port\n" addr value)))
        (vector-set! memory (region-index addr) value)))

  (define (handle-io-change)
    void;;TODO
    )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; instruction execution

  (define (execute! opcode [jump-addr-pos 0])
    (if (< opcode 8)
        ((vector-ref instructions opcode) (bitwise-bit-field I 0 jump-addr-pos))
        ((vector-ref instructions opcode))))

  (define (step0-helper)    
    (set! I (d-pop!))
    (set! P (incr P))
    (if (eq? I 'end)
        (suspend)
        (set! step-fn (if (execute! (bitwise-bit-field I 13 18) 10)
                          step1
                          step0))))
  (define (step0)
    (if (read-memory P)
        ;;TODO: FIX: this should not use the stack
        ;;           we could loose the last item on the stack this way
        (step0-helper)
        ;;else: we are now suspended waiting for the value
        (set! step-fn step0-helper)))

  (define (step1)
    (set! step-fn (if (execute! (bitwise-bit-field I 8 13) 8)
                      step2
                      step0)))

  (define (step2)
    (set! step-fn (if (execute! (bitwise-bit-field I 3 8) 3)
                      step3
                      step0)))

  (define (step3)
    (execute! (<< (bitwise-bit-field I 0 3) 2))
    (set! step-fn step0))

  (define step-fn step0)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; instructions

  ;; Define a new instruction. An instruction can
  ;; abort the rest of the current word by returning #f.
  (define-syntax-rule (define-instruction! opcode args body ...)
    (let ((n (or (vector-member opcode opcodes)
                 (raise (format "Err: invalid opcode: '~s'" opcode)))))
      (vector-set! instructions
                   n
                   (if DEBUG?
                       (lambda args
                         (printf (format "OPCODE: '~a'\n" opcode))
                         body ...)
                       (lambda args
                         body ...)))))

  (define-instruction! "ret" (_)
    (set! P R)
    (r-pop!)
    #f)

  (define-instruction! "ex" (_)
    (define temp P)
    (set! P R)
    (set! R temp)
    #f)

  (define-instruction! "jump" (addr)
    (when DEBUG? (printf "jump to ~a\n" addr))
    (set! P addr)
    #f)

  (define-instruction! "call" (addr)
    (when DEBUG? (printf "calling: ~a\n" addr))
    (r-push! P)
    (set! P addr)
    #f)

  (define-instruction! "unext" (_) ;; -- hacky!
    (if (= R 0)
        (r-pop!)
        (begin (set! R (sub1 R))
               (set! P (sub1 P))
               #f)))

  (define-instruction! "next" (addr)
    (if (= R 0)
        (begin (r-pop!)
               #f)
        (begin (set! R (sub1 R))
               (set! P addr)
               #f)))

  (define-instruction! "if" (addr)
    (and (= T 0)
         (begin (when DEBUG? (printf "If: jumping to ~a\n" addr))
                (set! P addr))
         #f))

  (define-instruction! "-if" (addr)
    (and (not (bitwise-bit-set? T 17))
         (set! P addr)
         #f))

  (define-instruction! "@p" ()
    (read-memory P)
    (set! P (incr P)))

  (define-instruction! "@+" () ; fetch-plus
    (read-memory A)
    (set! A (incr A)))

  (define-instruction! "@b" () ;fetch-b
    (read-memory B) #t)

  (define-instruction! "@" (); fetch a
    (read-memory A) #t)

  (define-instruction! "!p" () ; store p
    (set-memory! P (d-pop!))
    (set! P (incr P)) #t)

  (define-instruction! "!+" () ;store plus
    (set-memory! A (d-pop!))
    (set! A (incr A)) #t)

  (define-instruction! "!b" (); store-b
    (set-memory! B (d-pop!)) #t)

  (define-instruction! "!" (); store
    (set-memory! A (d-pop!)) #t)

  (define-instruction! "+*" () ; multiply-step
    ;;case 1 - If bit A0 is zero
    ;;  Treats T:A as a single 36 bit register and shifts it right by one
    ;;  bit. The most signficicant bit (T17) is kept the same.
    ;;case 2 - If bit A0 is one
    ;;  Sums T and S and concatenates the result with A, shifting
    ;;  everything to the right by one bit to replace T:A
    (if (& A 1)
        ;;case 2:
        (let* ([sum (if extended-arith?
                        (let ([sum (+ T S carry-bit)])
                          (set! carry-bit (& sum #x40000))
                          sum)
                        (+ T S))]
               [sum17 (& sum #x20000)]
               [result (ior (<< sum 17)
                            (>> A 1))])
          (set! A (bitwise-bit-field result 0 18))
          (set! T (ior sum17 (bitwise-bit-field result 18 36))))
        ;;case 2:
        (let ([t17 (& T #x20000)]
              [t0  (& T #x1)])
          (set! T (ior t17 (>> T 1)))
          (set! A (ior (<< t0 17)
                       (>> A 1))))))

  (define-instruction! "2*" ()
    (set! T (18bit (<< T 1))))

  (define-instruction! "2/" ()
    (set! T (>> T 1)))

  (define-instruction! "-" () ;not
    (set! T (18bit (bitwise-not T))))

  (define-instruction! "+" ()
    (if extended-arith?
        (let ([sum (+ (d-pop!) (d-pop!) carry-bit)])
          (set! carry-bit (& sum #x40000))
          (d-push! (18bit sum)))
        (d-push! (18bit (+ (d-pop!) (d-pop!))))))

  (define-instruction! "and" ()
    (d-push! (& (d-pop!) (d-pop!))))

  (define-instruction! "or" ()
    (d-push! (^ (d-pop!) (d-pop!))))

  (define-instruction! "drop" ()
    (d-pop!))

  (define-instruction! "dup" ()
    (d-push! T))

  (define-instruction! "pop" ()
    (d-push! (r-pop!)))

  (define-instruction! "over" ()
    (d-push! S))

  (define-instruction! "a" ()  ; read a
    (d-push! A));;??

  (define-instruction! "nop" () ;; .
    (void))

  (define-instruction! "push" ()
    (r-push! (d-pop!)))

  (define-instruction! "b!" () ;; store into b
    (set! B (d-pop!)))

  (define-instruction! "a!" () ;store into a
    (set! A (d-pop!)))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; public methods

  (defmacro declare-public (name)
    #`(vector-set! self
                   #,(string->symbol (string-append (symbol->string name) "-i"))
                   #,name))

  ;; (define (get-coord) coord)
  ;; (declare-public get-coord)
  (vector-set! self get-coord-i coord)

  (define (get-memory) memory)
  (declare-public get-memory)

  (define (get-rstack) rstack)
  (declare-public get-rstack)

  (define (get-dstack) dstack)
  (declare-public get-dstack)

  (define (get-registers) (list A B P I R S T))
  (declare-public get-registers)

  (define (load-code code)
    (define (load code index)
      (unless (null? code)
        (vector-set! memory index (car code))
        (load (cdr code) (add1 index))))
    (load code 0))
  (declare-public load-code)

  ;; Returns a snapshot of the current state.
  (define (current-state)
    (state A B P I R S T (copy-stack dstack) (copy-stack rstack) (vector-copy memory 0 MEM-SIZE)))
  (declare-public current-state)

  (define (setup-ports)
    (vector-set! memory &LEFT (vector (lambda () (port-read LEFT))
                                      (lambda (v) (port-write LEFT v))))
    (vector-set! memory &RIGHT (vector (lambda () (port-read RIGHT))
                                       (lambda (v) (port-write RIGHT v))))
    (vector-set! memory &UP (vector (lambda () (port-read UP))
                                    (lambda (v) (port-write UP v))))
    (vector-set! memory &DOWN (vector (lambda () (port-read DOWN))
                                      (lambda (v) (port-write DOWN v))))
    (vector-set! memory &IO (vector (lambda () IO)
                                    (lambda (v)
                                      (set! IO v)
                                      (handle-io-change)))))

  (define (reset! [bit 18])
    (set! A 0)
    (set! B 0)
    (set! P 0)
    (set! I 0)
    (set! R 0)
    (set! S 0)
    (set! T 0)
    (set! IO #x15555)
    (set! memory (make-vector MEM-SIZE 'end))
    (set! dstack (make-stack 8))
    (set! rstack (make-stack 8))
    (set! blocking-read #f)
    (set! blocking-write #f)
    (set! blocking #f)
    (set! writing-nodes (make-vector 4 #f))
    (set! reading-nodes (make-vector 4 #f))
    (set! port-vals (make-vector 4 #f))
    (setup-ports))
  (declare-public reset!)

  ;; Resets only p
  (define (reset-p! [start 0])
    (set! P start))
  (declare-public reset-p!)

  ;; Executes one step of the program by fetching a word, incrementing
  ;; p and executing the word.
  ;; returns #f when P = 0, else #t
  (define (step-program!)
    (when DEBUG? (printf "\nstep-program! node ~a\n" coord))
    (step-fn)
    (when (and DEBUG? DISPLAY_STATE?) (display-state (list coord))))

  (declare-public step-program!)

  ;; Steps the program n times.
  (define (step-program-n! n)
    (for ([i (in-range 0 n)]) (step-program!)))
  (declare-public step-program-n!)

  (define (init-ludr-port-nodes)
    (define (convert dir)
      (let ([x (remainder coord 100)]
            [y (quotient coord 100)])
        (cond [(equal? dir "north") (if (= (modulo y 2) 0) DOWN UP)]
              [(equal? dir "south") (if (= (modulo y 2) 0) UP DOWN)]
              [(equal? dir "east") (if (= (modulo x 2) 0) RIGHT LEFT)]
              [(equal? dir "west") (if (= (modulo x 2) 0) LEFT RIGHT)])))
    (let ([west (coord->node (- coord 1))]
          [north (coord->node (+ coord 100))]
          [south (coord->node (- coord 100))]
          [east (coord->node (+ coord 1))])
      (set! ludr-port-nodes (make-vector 4))
      (vector-set! ludr-port-nodes (convert "north") north)
      (vector-set! ludr-port-nodes (convert "east") east)
      (vector-set! ludr-port-nodes (convert "south") south)
      (vector-set! ludr-port-nodes (convert "west") west)))

  (declare-public init-ludr-port-nodes)

  (define (get-ludr-port-nodes) ludr-port-nodes)
  (declare-public get-ludr-port-nodes)

  (define (set-aindex index)
    (set! active-index index))
  (declare-public set-aindex)

  (define (str)
    (format "<node ~a>" coord))
  (declare-public str)

  self
  );;end make-node

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; execution control

(define (step-program!)
  (set! time (add1 time))
  (when (> current-node-index last-active-index)
    (set! current-node-index 0))
  (set! current-node (vector-ref active-nodes current-node-index))
  (node:step-program! current-node)
  (set! current-node-index (add1 current-node-index)))

(define (step-program-n! n)
  (when (> n 0)
    (step-program!)
    (step-program-n! (sub1 n))))

;;step program until all nodes are non-active
(define (step-program!* [max-time #f])
  (define (step)
    (unless (= last-active-index -1)
      (step-program!)
      (step)))
  (define (step-with-max)
    (unless (= last-active-index -1)
      (step-program!)
      (when (< time 1000000)
        (step-with-max))))
  (if max-time
      (step-with-max)
      (step)))

(define (reset!)
  (set! time 0)
  (set! last-active-index 143)
  (set! current-node-index 0)
  (set! current-node (vector-ref active-nodes current-node-index))
  (vector-map node:reset! nodes))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; state display functions

(define (display-dstack t s dstack)
  (printf "|d> ~x ~x" t s)
  (display-stack dstack)
  (newline))

(define (display-rstack r rstack)
  (printf "|r> ~x" r)
  (display-stack rstack)
  (newline))

(define (list-active-nodes)
  (if (>= last-active-index 0)
      (for/list ([i (add1 last-active-index)])
        (vector-ref active-nodes i))
      '()))

(define (display-state [nodes #f])
  (let ((nodes (if nodes
                   (map coord->node nodes)
                   (list-active-nodes))))
    (for ([node nodes])
      (printf "_____Node ~a state_____\n" (node:get-coord node))
      (let ((state (node:current-state node)))
        (printf "p:~a a:~a b:~a r:~a\n"
                (state-p state)
                (state-a state)
                (state-b state)
                (state-r state))
        (display-dstack (state-t state)
                        (state-s state)
                        (state-dstack state))
        (display-rstack (state-r state)
                        (state-rstack state))))))

(define (display-dstacks [nodes #f])
  (let ((nodes (if nodes
                   (map coord->node nodes)
                   (list-active-nodes))))
    (for ([node nodes])
      (let ((state (node:current-state node)))
        (display (format "(~a)|d> ~x ~x"
                         (node:get-coord node)
                         (state-t state)
                         (state-s state)))
        (display-stack (state-dstack state))
        (newline)))))

(define (display-memory coord [n MEM-SIZE])
  (let* ((node (coord->node coord))
         (mem (state-memory (node:current-state node)))
         (n (sub1 n)))
    (define (print i)
      (let ((v (vector-ref mem i)))
        (printf "~a " v)
        (unless (or (eq? v 'end)
                    (>= i n))
          (print (add1 i)))))
    (printf "node ~a memory: " coord)
    (print 0)
    (newline)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; methods

;; (defmacro method (name)
;;   #`(define #,(string->symbol (string-append (symbol->string name) "-i"))
;;       (begin (set! method-count (add1 method-count))
;;              method-count))
;;   )

(define N-METHODS 0)
(define (i) (let ([index N-METHODS])
              (set! N-METHODS (add1 N-METHODS))
              index))

(define get-coord-i (i))
(define (node:get-coord node) (vector-ref node get-coord-i))

(define get-memory-i (i))
(define (node:get-memory node) ((vector-ref node get-memory-i)))

(define get-rstack-i (i))
(define (node:get-rstack node) ((vector-ref node get-rstack-i)))

(define get-dstack-i (i))
(define (node:get-dstack node) ((vector-ref node get-dstack-i)))

(define get-registers-i (i))
(define (get-registers node) ((vector-ref node get-registers-i)))

(define load-code-i (i))
(define (node:load-code node code)
  ((vector-ref node load-code-i) code))

(define current-state-i (i))
(define (node:current-state node) ((vector-ref node current-state-i)))

(define reset!-i (i))
(define (node:reset! node) ((vector-ref node reset!-i)))

(define reset-p!-i (i))
(define (node:reset-p! node) ((vector-ref node reset-p!-i)))

(define step-program!-i (i))
(define (node:step-program! node)
  ((vector-ref node step-program!-i)))

(define step-program-n!-i (i))
(define (node:step-program-n! node n)
  ((vector-ref node step-program-n!-i) n))

(define init-ludr-port-nodes-i (i))
(define (node:init-ludr-port-nodes node)
  ((vector-ref node init-ludr-port-nodes-i)))

(define get-ludr-port-nodes-i (i))
(define (node:get-ludr-port-nodes node)
  ((vector-ref node get-ludr-port-nodes-i)))

(define set-aindex-i (i))
(define (node:set-aindex node index)
  ((vector-ref node set-aindex-i) index))

(define finish-port-read-i (i))
(define (node:finish-port-read node val)
  ((vector-ref node finish-port-read-i) val))

(define finish-port-write-i (i))
(define (node:finish-port-write node)
  ((vector-ref node finish-port-write-i)))

(define receive-port-read-i (i))
(define (node:receive-port-read node port _node)
  ((vector-ref node receive-port-read-i) port _node))

(define receive-port-write-i (i))
(define (node:receive-port-write node port value _node)
  ((vector-ref node receive-port-write-i) port value _node))

(define str-i (i))
(define (node:str node) ((vector-ref node str-i)))

(define (initialize)
  (build-node-matrix)
  (set! active-nodes (vector-copy nodes))
  (reset!)
  (void))

(initialize)
